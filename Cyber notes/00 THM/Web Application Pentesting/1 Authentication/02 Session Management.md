https://tryhackme.com/room/sessionmanagement

### Table of contents
- [[#Intro]]
- [[#Authentication vs Authorization]]
- [[#Cookies vs Tokens]]
- [[#Securing Session Lifecycle]]
- [[#Exploiting Insecure Session Management]]

___
### Intro
[[#Table of contents|Back to the top]]

Lifecycle
1. **Creation:** after providing credentials, sometimes even before because web app tracks actions regardless of authentication
2. **Tracking:** session value is submitted with each request
3. **Timeout / Expiry:** session value should have lifetime attached to it
4. **Termination:** after logout

___
### Authentication vs Authorization
[[#Table of contents|Back to the top]]

![[Pasted image 20260126091143.png]]

1. **Identification:** verifying *who* user is --> ***username***
2. **Authentication:** verifying user is who they *claim* they are --> ***password***
3. **Authorization:** allocating adequate *rights* to authenticated user
4. **Accountability:** creating record of user actions

***IAAA and Sessions Management:** authentication plays role in session creation, authorization plays role in what actions user can perform, accountability makes sure each user action can be connected to a session*

___
### Cookies vs Tokens
[[#Table of contents|Back to the top]]

#### Cookie-Based SM

Web app starts session --> set value for Set-Cookie header

`Set-Cookie: session=12345;`
*Browser creates cookie entry for cookie named "session" with value "12345", valid for domain where cookie was received from*

Some other potential attributes of cookies (more [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Set-Cookie))
- `Secure`: cookie only transmitted over HTTP**S**
- `HTTPOnly`: cookie value not read by client-side JS
- `Expire`: expiry date-time
- `SameSite`: cookie can or can't be transmitted cross-site

**NB:** **browser decides** when cookie value is sent after reviewing cookie domain and attributes

#### Token-Based SM

Relies on client-side code

Authentication --> token within request body, client-side JS code stores token in browser's `LocalStorage`
New request --> JS loads token from storage, attaches it as header

**JWT** - JSON Web Tokens: common tokens, passed through `Authorization: Bearer` header


| **Cookie-Session Management**                                                                                                      | **Token-Based Session Management**                                                                                                                  |
| ---------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| Automatically sent by browser with each request                                                                                    | Has to be submitted as header with each request using client-side JS                                                                                |
| Attributes can be used to enhance browser's protection of cookie                                                                   | Do not have automatic security protections enforced, should be safeguarded against disclosures                                                      |
| Can be vulnerable to conventional client-side attacks such as CSRF, where browser is tricked into making request on behalf of user | Not automatically added to request, cannot be read from LocalStorage by other domains --> conventional client-side attacks such as CSRF are blocked |
| Locked to specific domain --> difficult to use securely in decentralised web applications                                          | Work well in decentralised web applications, can often contain all the information required to verify token itself                                  |

___
### Securing Session Lifecycle
[[#Table of contents|Back to the top]]
#### Creation

**Weak Session Value**
Uncommon, but could still be relevant because of AI assisted coding
Custom session creation mechanism --> session values may be guessable
*Example:* session value = base64(username) --> easily reverse engineered

**Controllable Session Values**
Some tokens creation and verification information is available (JWT), without security measures (verifying signature) attacker can generate own token

**Session Fixation**
Web app that gives session before authentication
Value not modified once authenticated --> attacker could record unauthenticated value and wait for target to authenticate to access session

**Insecure Session Transmission**
In SSO session info has to be transmitted
Without proper security measures, attacker could control URL to which user is redirected for instance

#### Tracking

**Authorization Bypass**
Not enough authorization checks
- **Vertical** bypass: can perform action of more privileged user
- **Horizontal** bypass: can perform action at same privilege level but from dataset that shouldn't be accessible

**Insufficient Logging**
Not enough info to understand incident, usually enough logging at infrastructure level but not at application level, action that seem legitimate should be logged

#### Expiry

Excessive time, if lifetime --> account for location: location changes --> terminate

#### Termination

Not properly terminated server-side --> even if target is aware of compromission, they can't really terminate session for attacker, upon password reset, all sessions should be terminated


___
### Exploiting Insecure Session Management
[[#Table of contents|Back to the top]]

**Enumeration**
Map out session management lifecycle

1. **Navigate** to target web app
2. Open **Inspector** > **Storage** (using Burp Suite can be useful too)
	- If no cookie/session then --> unauthenticated session likely to not be tracked
3. Click "**Sign Up**": identify types of sign ups (Student, Lecturer (requires verification code) in example)
4. Create student account
5. **Login** > monitor network traffic
	- Cookie-based / Token-based
	- Cookie flags (HTTPOnly, ...)
6. **Explore** website once **authenticated** --> notice if cookie is sent with each request --> session tracking, try sending **requests without cookie** to see what can be **accessed unauthenticated**
7. **Logout** --> notice if session is removed client-side
8. Re-authenticate and **replace new cookie with old cookie** to test for **server-side** termination
9. Play around with locally stored data --> try to vertical bypass (Student --> Lecturer)

___
***Example summary***

| **Phase**   | **Observation**                                                                        |
| ----------- | -------------------------------------------------------------------------------------- |
| Creation    | Combination of cookie- and token-based session management                              |
| Creation    | New session value is provided for each login attempt                                   |
| Creation    | Session value itself appears to be sufficiently random                                 |
| Tracking    | Unauthenticated actions not tracked via session                                        |
| Tracking    | Cookie sent in each request for tracking                                               |
| Tracking    | Several requests can be made without cookie                                            |
| Tracking    | Initial token values that are loaded post-authentication dictate visible information   |
| Expiry      | Mismatch between client-side and server-side expiry times                              |
| Expiry      | Expiry time incredibly long                                                            |
| Termination | Users can forcibly terminate session                                                   |
| Termination | Sessions terminated server-side but reusing old session leads to internal server error |
Vulnerabilities to be reported
- Excessive Session Lifetimes

Further investigation
- Access controls on all API endpoints
- Web app logs